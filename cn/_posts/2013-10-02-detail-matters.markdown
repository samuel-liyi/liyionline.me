---
layout: post
date: 2013-10-02 18:28:11
title: 细节真的很重要
categories: [Work,cn]
tags: [python,work]
---

* 今天实习的时候遇到的一个任务，是要从若干张表中按照另外一张表中的两个字段（分别是表名和字段名）到其中某一个表中提取出对应的另外一个字段，最后把这三个字段拼接到完整的一个表中去。由于要确定的这个字段其实是数据库中的数据类型，像什么varchar(20),number(20,4)这些东西，按理说不同表之间相同的字段应该类型相同，所以这个应该很简单，但事实上由于各个表的负责可能是由不同的人来完成，或者说数据库整体的设计没有完全保持一致，结果就是直接按照字段提取，忽略表名是行不通的。

* 所以我只能按照表名和字段名两个标准去那一堆表中寻找了，平常excel中用的比较多的当然是lookup系类函数,但是这里其实要用到双重的判断标准，我当时想了想，觉得vlookup实现起来可能不简单，所以干脆借助其他工具好了

* 首先从所有的表中把我要的三个字段（表名，字段名，数据类型）全部提取到R里面（这步当然只能手工。。。）,rbind成一个大的Data.Frame,这里还有个小教训

> 因为像表名，字段名这样的东西当然是字符串类型了，由于我在读入的时候使用了*read.table()*函数，而*read.table()*函数在R里面默认会把字符串类型的数据列直接转换成因子（factor），其实这导致我后来处理起来反而不是很方便，因为后来在筛选的时候的逻辑判断和子集的选取，其实直接字符串就可以了。


>p.s.:其实转化为因子也是有道理的，因为因子其实是一种经济的存储字符串序列的方式，特别是同一列中有大量重复的值的时候，它直接把所有的level存起来，然后每个位置只要以整数形式存储level中的位置即可。其实把factor对应到原始值也很容易，直接*levels(x)[x]*即可

* 然后就是把我要查找的那一张表的前两个字段同样载入到R中，接下来的工作似乎应该无比简单了：

 >result[i]=d1[d1$V1==a[i,1]&&d1$V2==a[i,2],][3]

但是然后蛋疼的问题就出现了，一开始没搞明白怎么结果不对，后来发现是在行的逻辑判断上出了问题，再到后来，才发现其实是&&和&的区别，跑到[SO][so]上看了看，这才想起来&是向量化的运算符，而&&不是.....所以说细节没有掌握好，往往会让你错的莫名其妙。

p.s.:晚上特意查了一下lookup的multiple-criteria的情况，发现excel确实是可以实现的，可以参见[这里][ex]
p.s.s: 越来越喜欢python了，一门编程语言的强大与否，除了创始人的远见卓识之外，恐怕就要取决于它的社区生态了，python 的community真的很强大，这两天在地铁上看[Python For Data Analysis][py]觉得python真的是太全能了，相比于R这样domain-specific的语言来说，python的易用性和功能的完备性确实是很大的优势，好多R的数据功能，python都有，甚至有的做的更好，看到[pandas][pd]作者介绍说，[pandas][pd]处理时间序列结构的数据就要比R中还要功能多。

[ex]:http://www.mrexcel.com/forum/excel-questions/306615-vlookup-multiple-criteria.html
[so]:http://stackoverflow.com/questions/6558921/r-boolean-operators-and
[py]:http://shop.oreilly.com/product/0636920023784.do
[pd]:http://pandas.pydata.org/